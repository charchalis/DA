\doxysection{code/algorithms.cpp File Reference}
\hypertarget{algorithms_8cpp}{}\label{algorithms_8cpp}\index{code/algorithms.cpp@{code/algorithms.cpp}}


This file contains implementations of TSP algorithms using different techniques/approaches, as well as the utility functions used in them.  


{\ttfamily \#include $<$unordered\+\_\+set$>$}\newline
{\ttfamily \#include $<$math.\+h$>$}\newline
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
double \mbox{\hyperlink{algorithms_8cpp_a6f8c3fb1951a1f05e6b2c8b37cda0a76}{tsp\+\_\+backtracking\+\_\+iteration}} (Graph$<$ int $>$ g, Vertex$<$ int $>$ \texorpdfstring{$\ast$}{*}curr, std\+::vector$<$ int $>$ \&path, double cost, double \&min\+\_\+cost, std\+::vector$<$ int $>$ \&best\+\_\+path)
\begin{DoxyCompactList}\small\item\em Utility function to perform backtracking for TSP. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{algorithms_8cpp_a1f4e302060adb98b28f67602780f019f}{tsp\+\_\+backtracking}} (Graph$<$ int $>$ g, const int start, std\+::vector$<$ int $>$ \&best\+\_\+path)
\begin{DoxyCompactList}\small\item\em Function to start the TSP backtracking. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{algorithms_8cpp_a8b46ff3a5dc6c342348e977165ca3dbc}{vector\+Contains\+Val}} (std\+::vector$<$ int $>$ vec, int val)
\begin{DoxyCompactList}\small\item\em Auxiliary function that checks if a vector contains a given value. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{algorithms_8cpp_a0fb8f9da22252c42a0c4809b9f9def07}{swap\+\_\+values}} (std\+::vector$<$ int $>$ original, int pos1, int pos2, std\+::vector$<$ int $>$ \&modified)
\begin{DoxyCompactList}\small\item\em Swap the two values in the vector to generate a new neighbor. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{algorithms_8cpp_a0b45649b16cd8fb687985b5be820b74a}{is\+\_\+val\+\_\+in\+\_\+vector}} (std\+::vector$<$ int $>$ vec, int val)
\begin{DoxyCompactList}\small\item\em Verifies if a given value exists in the given vector. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{algorithms_8cpp_ad98321d397e3cd44eb7008becad3b589}{generates\+\_\+random\+\_\+vertex}} (std\+::vector$<$ int $>$ swapped\+Vertexes, int path\+Size, bool is\+Start\+Vertex)
\begin{DoxyCompactList}\small\item\em Generates a random unswapped vertex so that it can be swapped using our neighboring function. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{algorithms_8cpp_ad636dec4a7274e831cde1dc219b98158}{generate\+\_\+neighbors}} (std\+::vector$<$ int $>$ path, std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \&neighbors, bool tweakable\+\_\+param)
\begin{DoxyCompactList}\small\item\em Generates the neighbors of a given path. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{algorithms_8cpp_a0c75d0e1c4e432164afede952e34ceff}{get\+\_\+path\+\_\+cost\+\_\+feasibility}} (std\+::vector$<$ int $>$ path, Graph$<$ int $>$ \&g, bool \&is\+Path\+Feasible, double \&path\+Cost)
\begin{DoxyCompactList}\small\item\em Gets the cost of a given path, as well as its feasibility. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{algorithms_8cpp_a914120bda1db570cdd5f676d3ce5e90d}{find\+\_\+start\+\_\+path}} (Graph$<$ int $>$ \&g, int start\+\_\+node, vector$<$ int $>$ \&starting\+\_\+path)
\begin{DoxyCompactList}\small\item\em Generates a random path from the graph. Not known to be feasible, Since we load in the whole graph all the nodes are added to it. But only some edges are loaded based on the dataset. There are some cases, ie. extra fully connected graphs dataset were we only need a small percentege of them. So, in order to avoid generating a path with nodes that are not loaded in, we only load the nodes which have edges assigned. Therefore avoiding the generation of paths with no edges assigned which would break our algorithm since we would no longer have a fully connected graph. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{algorithms_8cpp_a6d53a990c8cec6885ae0d34e48db29cd}{update\+\_\+tabu\+\_\+list}} (std\+::map$<$ std\+::vector$<$ int $>$, int $>$ \&tabu\+\_\+list)
\begin{DoxyCompactList}\small\item\em Updates the tabu list by decreasing the tenure of each path and removing those with expired tenure. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{algorithms_8cpp_a74f9ffdbf0cc13e83342a82e1918539b}{meets\+\_\+aspiration\+\_\+criteria}} (std\+::vector$<$ int $>$ path, std\+::map$<$ std\+::vector$<$ int $>$, int $>$ tabu\+\_\+list, int tabu\+\_\+tenure, double best\+\_\+cost)
\begin{DoxyCompactList}\small\item\em Checks if a given path meets the aspiration criteria in Tabu Search. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{algorithms_8cpp_aebd8c7a0a578c04a5751a972ecaca17a}{tabu\+\_\+search}} (Graph$<$ int $>$ \&g, std\+::vector$<$ int $>$ starting\+\_\+path, double starting\+\_\+cost, std\+::vector$<$ int $>$ \&best\+\_\+path, double \&best\+\_\+cost)
\begin{DoxyCompactList}\small\item\em Performs the Tabu Search algorithm to find the optimal path in a graph. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{algorithms_8cpp_a0e872e775c5f2167f9ce3f9649f52845}{T2\+\_\+3}} (Graph$<$ int $>$ \&g)
\begin{DoxyCompactList}\small\item\em Function to demonstrate the tabu search algorithm on a graph. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{algorithms_8cpp_af13935b1770316633a1629fd39a5ff1a}{prim\+Using\+Edges}} (Graph$<$ int $>$ g, int start, vector$<$ Edge$<$ int $>$ \texorpdfstring{$\ast$}{*} $>$ \&mst\+Edges)
\begin{DoxyCompactList}\small\item\em this is the prim algorithm for distance datasets (as opposed to coordinate datasets) \end{DoxyCompactList}\item 
double \mbox{\hyperlink{algorithms_8cpp_afe4e7a479e4a8cba5dbb9162cec10d74}{calculate\+Distance}} (Vertex$<$ int $>$ \texorpdfstring{$\ast$}{*}v, Vertex$<$ int $>$ \texorpdfstring{$\ast$}{*}w)
\begin{DoxyCompactList}\small\item\em Calculates the distance between two vertices using their geographical coordinates. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{algorithms_8cpp_a7ab8f7f2df9abd7ae4fdf38d1f3ea450}{prim\+Using\+Coords}} (Graph$<$ int $>$ g, int start, vector$<$ Edge$<$ int $>$ \texorpdfstring{$\ast$}{*} $>$ \&mst\+Edges)
\begin{DoxyCompactList}\small\item\em Prim\textquotesingle{}s algorithm for coordinates datasets. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{algorithms_8cpp_a0e587049579507b6e91f11255a8d107c}{T2\+\_\+2}} (Graph$<$ int $>$ g)
\begin{DoxyCompactList}\small\item\em Function to demonstrate Prim\textquotesingle{}s algorithm using both edge weights and vertex coordinates. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{algorithms_8cpp_a952eac791b596a61bba0a133a3bb439f}\label{algorithms_8cpp_a952eac791b596a61bba0a133a3bb439f} 
const double {\bfseries PI} = 3.\+14159265358979323846
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This file contains implementations of TSP algorithms using different techniques/approaches, as well as the utility functions used in them. 



\doxysubsection{Function Documentation}
\Hypertarget{algorithms_8cpp_afe4e7a479e4a8cba5dbb9162cec10d74}\label{algorithms_8cpp_afe4e7a479e4a8cba5dbb9162cec10d74} 
\index{algorithms.cpp@{algorithms.cpp}!calculateDistance@{calculateDistance}}
\index{calculateDistance@{calculateDistance}!algorithms.cpp@{algorithms.cpp}}
\doxysubsubsection{\texorpdfstring{calculateDistance()}{calculateDistance()}}
{\footnotesize\ttfamily double calculate\+Distance (\begin{DoxyParamCaption}\item[{Vertex$<$ int $>$ \texorpdfstring{$\ast$}{*}}]{v,  }\item[{Vertex$<$ int $>$ \texorpdfstring{$\ast$}{*}}]{w }\end{DoxyParamCaption})}



Calculates the distance between two vertices using their geographical coordinates. 


\begin{DoxyParams}{Parameters}
{\em v} & The first vertex. \\
\hline
{\em w} & The second vertex. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The calculated distance between the two vertices.
\end{DoxyReturn}
@timecomplexity O(1) \Hypertarget{algorithms_8cpp_a914120bda1db570cdd5f676d3ce5e90d}\label{algorithms_8cpp_a914120bda1db570cdd5f676d3ce5e90d} 
\index{algorithms.cpp@{algorithms.cpp}!find\_start\_path@{find\_start\_path}}
\index{find\_start\_path@{find\_start\_path}!algorithms.cpp@{algorithms.cpp}}
\doxysubsubsection{\texorpdfstring{find\_start\_path()}{find\_start\_path()}}
{\footnotesize\ttfamily void find\+\_\+start\+\_\+path (\begin{DoxyParamCaption}\item[{Graph$<$ int $>$ \&}]{g,  }\item[{int}]{start\+\_\+node,  }\item[{vector$<$ int $>$ \&}]{starting\+\_\+path }\end{DoxyParamCaption})}



Generates a random path from the graph. Not known to be feasible, Since we load in the whole graph all the nodes are added to it. But only some edges are loaded based on the dataset. There are some cases, ie. extra fully connected graphs dataset were we only need a small percentege of them. So, in order to avoid generating a path with nodes that are not loaded in, we only load the nodes which have edges assigned. Therefore avoiding the generation of paths with no edges assigned which would break our algorithm since we would no longer have a fully connected graph. 

This function ensures that only nodes with edges assigned are included in the generated path, avoiding paths that break the algorithm due to disconnected nodes.


\begin{DoxyParams}{Parameters}
{\em g} & Graph containing the vertices and edges. \\
\hline
{\em start\+\_\+node} & The starting node for the path. \\
\hline
{\em starting\+\_\+path} & Vector to store the generated starting path.\\
\hline
\end{DoxyParams}
@timecomplexity O(n) where n is the number of vertices in the graph. \Hypertarget{algorithms_8cpp_ad636dec4a7274e831cde1dc219b98158}\label{algorithms_8cpp_ad636dec4a7274e831cde1dc219b98158} 
\index{algorithms.cpp@{algorithms.cpp}!generate\_neighbors@{generate\_neighbors}}
\index{generate\_neighbors@{generate\_neighbors}!algorithms.cpp@{algorithms.cpp}}
\doxysubsubsection{\texorpdfstring{generate\_neighbors()}{generate\_neighbors()}}
{\footnotesize\ttfamily void generate\+\_\+neighbors (\begin{DoxyParamCaption}\item[{std\+::vector$<$ int $>$}]{path,  }\item[{std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \&}]{neighbors,  }\item[{bool}]{tweakable\+\_\+param }\end{DoxyParamCaption})}



Generates the neighbors of a given path. 


\begin{DoxyParams}{Parameters}
{\em path} & Original path. \\
\hline
{\em neighbors} & Vector to store the generated neighbors. \\
\hline
{\em tweakable\+\_\+param} & Boolean to tweak the number of neighbors generated.\\
\hline
\end{DoxyParams}
@timecomplexity The time complexity is O(n\texorpdfstring{$^\wedge$}{\string^}2), where n is the size of the path. \Hypertarget{algorithms_8cpp_ad98321d397e3cd44eb7008becad3b589}\label{algorithms_8cpp_ad98321d397e3cd44eb7008becad3b589} 
\index{algorithms.cpp@{algorithms.cpp}!generates\_random\_vertex@{generates\_random\_vertex}}
\index{generates\_random\_vertex@{generates\_random\_vertex}!algorithms.cpp@{algorithms.cpp}}
\doxysubsubsection{\texorpdfstring{generates\_random\_vertex()}{generates\_random\_vertex()}}
{\footnotesize\ttfamily int generates\+\_\+random\+\_\+vertex (\begin{DoxyParamCaption}\item[{std\+::vector$<$ int $>$}]{swapped\+Vertexes,  }\item[{int}]{path\+Size,  }\item[{bool}]{is\+Start\+Vertex }\end{DoxyParamCaption})}



Generates a random unswapped vertex so that it can be swapped using our neighboring function. 


\begin{DoxyParams}{Parameters}
{\em swapped\+Vertexes} & Vector of already swapped vertexes. \\
\hline
{\em path\+Size} & Size of the path. \\
\hline
{\em is\+Start\+Vertex} & Boolean indicating if it is the start vertex. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int Random vertex generated.
\end{DoxyReturn}
@timecomplexity The time complexity is O(1). \Hypertarget{algorithms_8cpp_a0c75d0e1c4e432164afede952e34ceff}\label{algorithms_8cpp_a0c75d0e1c4e432164afede952e34ceff} 
\index{algorithms.cpp@{algorithms.cpp}!get\_path\_cost\_feasibility@{get\_path\_cost\_feasibility}}
\index{get\_path\_cost\_feasibility@{get\_path\_cost\_feasibility}!algorithms.cpp@{algorithms.cpp}}
\doxysubsubsection{\texorpdfstring{get\_path\_cost\_feasibility()}{get\_path\_cost\_feasibility()}}
{\footnotesize\ttfamily void get\+\_\+path\+\_\+cost\+\_\+feasibility (\begin{DoxyParamCaption}\item[{std\+::vector$<$ int $>$}]{path,  }\item[{Graph$<$ int $>$ \&}]{g,  }\item[{bool \&}]{is\+Path\+Feasible,  }\item[{double \&}]{path\+Cost }\end{DoxyParamCaption})}



Gets the cost of a given path, as well as its feasibility. 


\begin{DoxyParams}{Parameters}
{\em path} & Path to be evaluated. \\
\hline
{\em g} & Graph containing the vertices and edges. \\
\hline
{\em is\+Path\+Feasible} & Boolean indicating if the path is feasible. \\
\hline
{\em path\+Cost} & Cost of the path.\\
\hline
\end{DoxyParams}
@timecomplexity The time complexity is O(n\texorpdfstring{$\ast$}{*}m), where n is the number of vertices and m is the number of edges. \Hypertarget{algorithms_8cpp_a0b45649b16cd8fb687985b5be820b74a}\label{algorithms_8cpp_a0b45649b16cd8fb687985b5be820b74a} 
\index{algorithms.cpp@{algorithms.cpp}!is\_val\_in\_vector@{is\_val\_in\_vector}}
\index{is\_val\_in\_vector@{is\_val\_in\_vector}!algorithms.cpp@{algorithms.cpp}}
\doxysubsubsection{\texorpdfstring{is\_val\_in\_vector()}{is\_val\_in\_vector()}}
{\footnotesize\ttfamily bool is\+\_\+val\+\_\+in\+\_\+vector (\begin{DoxyParamCaption}\item[{std\+::vector$<$ int $>$}]{vec,  }\item[{int}]{val }\end{DoxyParamCaption})}



Verifies if a given value exists in the given vector. 


\begin{DoxyParams}{Parameters}
{\em vec} & Vector to be checked. \\
\hline
{\em val} & Value to be checked for. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True if the vector contains the value, false otherwise.
\end{DoxyReturn}
@timecomplexity The time complexity is O(n), where n is the size of the vector. \Hypertarget{algorithms_8cpp_a74f9ffdbf0cc13e83342a82e1918539b}\label{algorithms_8cpp_a74f9ffdbf0cc13e83342a82e1918539b} 
\index{algorithms.cpp@{algorithms.cpp}!meets\_aspiration\_criteria@{meets\_aspiration\_criteria}}
\index{meets\_aspiration\_criteria@{meets\_aspiration\_criteria}!algorithms.cpp@{algorithms.cpp}}
\doxysubsubsection{\texorpdfstring{meets\_aspiration\_criteria()}{meets\_aspiration\_criteria()}}
{\footnotesize\ttfamily bool meets\+\_\+aspiration\+\_\+criteria (\begin{DoxyParamCaption}\item[{std\+::vector$<$ int $>$}]{path,  }\item[{std\+::map$<$ std\+::vector$<$ int $>$, int $>$}]{tabu\+\_\+list,  }\item[{int}]{tabu\+\_\+tenure,  }\item[{double}]{best\+\_\+cost }\end{DoxyParamCaption})}



Checks if a given path meets the aspiration criteria in Tabu Search. 


\begin{DoxyParams}{Parameters}
{\em path} & The current path. \\
\hline
{\em tabu\+\_\+list} & The list of tabu paths with their tenures. \\
\hline
{\em tabu\+\_\+tenure} & The tenure of the tabu list. \\
\hline
{\em best\+\_\+cost} & The best cost found so far. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the path meets the aspiration criteria, false otherwise.
\end{DoxyReturn}
@timecomplexity O(1) \Hypertarget{algorithms_8cpp_a7ab8f7f2df9abd7ae4fdf38d1f3ea450}\label{algorithms_8cpp_a7ab8f7f2df9abd7ae4fdf38d1f3ea450} 
\index{algorithms.cpp@{algorithms.cpp}!primUsingCoords@{primUsingCoords}}
\index{primUsingCoords@{primUsingCoords}!algorithms.cpp@{algorithms.cpp}}
\doxysubsubsection{\texorpdfstring{primUsingCoords()}{primUsingCoords()}}
{\footnotesize\ttfamily double prim\+Using\+Coords (\begin{DoxyParamCaption}\item[{Graph$<$ int $>$}]{g,  }\item[{int}]{start,  }\item[{vector$<$ Edge$<$ int $>$ \texorpdfstring{$\ast$}{*} $>$ \&}]{mst\+Edges }\end{DoxyParamCaption})}



Prim\textquotesingle{}s algorithm for coordinates datasets. 


\begin{DoxyParams}{Parameters}
{\em g} & The graph containing the vertices. \\
\hline
{\em start} & The starting vertex. \\
\hline
{\em mst\+Edges} & Output parameter to store the MST edges. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The total weight of the MST.
\end{DoxyReturn}
@timecomplexity O(n\texorpdfstring{$^\wedge$}{\string^}2 log n) \Hypertarget{algorithms_8cpp_af13935b1770316633a1629fd39a5ff1a}\label{algorithms_8cpp_af13935b1770316633a1629fd39a5ff1a} 
\index{algorithms.cpp@{algorithms.cpp}!primUsingEdges@{primUsingEdges}}
\index{primUsingEdges@{primUsingEdges}!algorithms.cpp@{algorithms.cpp}}
\doxysubsubsection{\texorpdfstring{primUsingEdges()}{primUsingEdges()}}
{\footnotesize\ttfamily double prim\+Using\+Edges (\begin{DoxyParamCaption}\item[{Graph$<$ int $>$}]{g,  }\item[{int}]{start,  }\item[{vector$<$ Edge$<$ int $>$ \texorpdfstring{$\ast$}{*} $>$ \&}]{mst\+Edges }\end{DoxyParamCaption})}



this is the prim algorithm for distance datasets (as opposed to coordinate datasets) 


\begin{DoxyParams}{Parameters}
{\em g} & The graph. \\
\hline
{\em start} & The starting vertex. \\
\hline
{\em mst\+Edges} & Output parameter to store the MST edges. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The total weight of the MST.
\end{DoxyReturn}
@timecomplexity O((n + m) log n) \Hypertarget{algorithms_8cpp_a0fb8f9da22252c42a0c4809b9f9def07}\label{algorithms_8cpp_a0fb8f9da22252c42a0c4809b9f9def07} 
\index{algorithms.cpp@{algorithms.cpp}!swap\_values@{swap\_values}}
\index{swap\_values@{swap\_values}!algorithms.cpp@{algorithms.cpp}}
\doxysubsubsection{\texorpdfstring{swap\_values()}{swap\_values()}}
{\footnotesize\ttfamily void swap\+\_\+values (\begin{DoxyParamCaption}\item[{std\+::vector$<$ int $>$}]{original,  }\item[{int}]{pos1,  }\item[{int}]{pos2,  }\item[{std\+::vector$<$ int $>$ \&}]{modified }\end{DoxyParamCaption})}



Swap the two values in the vector to generate a new neighbor. 


\begin{DoxyParams}{Parameters}
{\em original} & Original vector. \\
\hline
{\em pos1} & Position of the first value. \\
\hline
{\em pos2} & Position of the second value. \\
\hline
{\em modified} & Vector to store the modified version.\\
\hline
\end{DoxyParams}
@timecomplexity The time complexity is O(n), where n is the size of the vector. \Hypertarget{algorithms_8cpp_a0e587049579507b6e91f11255a8d107c}\label{algorithms_8cpp_a0e587049579507b6e91f11255a8d107c} 
\index{algorithms.cpp@{algorithms.cpp}!T2\_2@{T2\_2}}
\index{T2\_2@{T2\_2}!algorithms.cpp@{algorithms.cpp}}
\doxysubsubsection{\texorpdfstring{T2\_2()}{T2\_2()}}
{\footnotesize\ttfamily void T2\+\_\+2 (\begin{DoxyParamCaption}\item[{Graph$<$ int $>$}]{g }\end{DoxyParamCaption})}



Function to demonstrate Prim\textquotesingle{}s algorithm using both edge weights and vertex coordinates. 


\begin{DoxyParams}{Parameters}
{\em g} & The graph to be used for the demonstration. \\
\hline
\end{DoxyParams}
\Hypertarget{algorithms_8cpp_a0e872e775c5f2167f9ce3f9649f52845}\label{algorithms_8cpp_a0e872e775c5f2167f9ce3f9649f52845} 
\index{algorithms.cpp@{algorithms.cpp}!T2\_3@{T2\_3}}
\index{T2\_3@{T2\_3}!algorithms.cpp@{algorithms.cpp}}
\doxysubsubsection{\texorpdfstring{T2\_3()}{T2\_3()}}
{\footnotesize\ttfamily void T2\+\_\+3 (\begin{DoxyParamCaption}\item[{Graph$<$ int $>$ \&}]{g }\end{DoxyParamCaption})}



Function to demonstrate the tabu search algorithm on a graph. 


\begin{DoxyParams}{Parameters}
{\em g} & The graph to be used for the demonstration. \\
\hline
\end{DoxyParams}
\Hypertarget{algorithms_8cpp_aebd8c7a0a578c04a5751a972ecaca17a}\label{algorithms_8cpp_aebd8c7a0a578c04a5751a972ecaca17a} 
\index{algorithms.cpp@{algorithms.cpp}!tabu\_search@{tabu\_search}}
\index{tabu\_search@{tabu\_search}!algorithms.cpp@{algorithms.cpp}}
\doxysubsubsection{\texorpdfstring{tabu\_search()}{tabu\_search()}}
{\footnotesize\ttfamily void tabu\+\_\+search (\begin{DoxyParamCaption}\item[{Graph$<$ int $>$ \&}]{g,  }\item[{std\+::vector$<$ int $>$}]{starting\+\_\+path,  }\item[{double}]{starting\+\_\+cost,  }\item[{std\+::vector$<$ int $>$ \&}]{best\+\_\+path,  }\item[{double \&}]{best\+\_\+cost }\end{DoxyParamCaption})}



Performs the Tabu Search algorithm to find the optimal path in a graph. 


\begin{DoxyParams}{Parameters}
{\em g} & The graph on which the search is performed. \\
\hline
{\em starting\+\_\+path} & The initial path to start the search. \\
\hline
{\em starting\+\_\+cost} & The cost of the initial path. \\
\hline
{\em best\+\_\+path} & Output parameter to store the best path found. \\
\hline
{\em best\+\_\+cost} & Output parameter to store the cost of the best path found.\\
\hline
\end{DoxyParams}
@timecomplexity O(iterations \texorpdfstring{$\ast$}{*} neighbors \texorpdfstring{$\ast$}{*} (log neighbors + feasibility check)) \Hypertarget{algorithms_8cpp_a1f4e302060adb98b28f67602780f019f}\label{algorithms_8cpp_a1f4e302060adb98b28f67602780f019f} 
\index{algorithms.cpp@{algorithms.cpp}!tsp\_backtracking@{tsp\_backtracking}}
\index{tsp\_backtracking@{tsp\_backtracking}!algorithms.cpp@{algorithms.cpp}}
\doxysubsubsection{\texorpdfstring{tsp\_backtracking()}{tsp\_backtracking()}}
{\footnotesize\ttfamily double tsp\+\_\+backtracking (\begin{DoxyParamCaption}\item[{Graph$<$ int $>$}]{g,  }\item[{const int}]{start,  }\item[{std\+::vector$<$ int $>$ \&}]{best\+\_\+path }\end{DoxyParamCaption})}



Function to start the TSP backtracking. 


\begin{DoxyParams}{Parameters}
{\em g} & Graph containing the vertices and edges. \\
\hline
{\em start} & Starting vertex for TSP. \\
\hline
{\em best\+\_\+path} & Vector to store the best path found. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
double Minimum cost found.
\end{DoxyReturn}
@timecomplexity The time complexity is O(n!), where n is the number of vertices in the graph. \Hypertarget{algorithms_8cpp_a6f8c3fb1951a1f05e6b2c8b37cda0a76}\label{algorithms_8cpp_a6f8c3fb1951a1f05e6b2c8b37cda0a76} 
\index{algorithms.cpp@{algorithms.cpp}!tsp\_backtracking\_iteration@{tsp\_backtracking\_iteration}}
\index{tsp\_backtracking\_iteration@{tsp\_backtracking\_iteration}!algorithms.cpp@{algorithms.cpp}}
\doxysubsubsection{\texorpdfstring{tsp\_backtracking\_iteration()}{tsp\_backtracking\_iteration()}}
{\footnotesize\ttfamily double tsp\+\_\+backtracking\+\_\+iteration (\begin{DoxyParamCaption}\item[{Graph$<$ int $>$}]{g,  }\item[{Vertex$<$ int $>$ \texorpdfstring{$\ast$}{*}}]{curr,  }\item[{std\+::vector$<$ int $>$ \&}]{path,  }\item[{double}]{cost,  }\item[{double \&}]{min\+\_\+cost,  }\item[{std\+::vector$<$ int $>$ \&}]{best\+\_\+path }\end{DoxyParamCaption})}



Utility function to perform backtracking for TSP. 


\begin{DoxyParams}{Parameters}
{\em g} & Graph containing the vertices and edges. \\
\hline
{\em curr} & Current vertex in the path. \\
\hline
{\em path} & Vector containing the current path. \\
\hline
{\em cost} & Current cost of the path. \\
\hline
{\em min\+\_\+cost} & Minimum cost found so far. \\
\hline
{\em best\+\_\+path} & Vector containing the best path found. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
double Minimum cost found.
\end{DoxyReturn}
@timecomplexity The time complexity is O(n!), where n is the number of vertices in the graph. \Hypertarget{algorithms_8cpp_a6d53a990c8cec6885ae0d34e48db29cd}\label{algorithms_8cpp_a6d53a990c8cec6885ae0d34e48db29cd} 
\index{algorithms.cpp@{algorithms.cpp}!update\_tabu\_list@{update\_tabu\_list}}
\index{update\_tabu\_list@{update\_tabu\_list}!algorithms.cpp@{algorithms.cpp}}
\doxysubsubsection{\texorpdfstring{update\_tabu\_list()}{update\_tabu\_list()}}
{\footnotesize\ttfamily void update\+\_\+tabu\+\_\+list (\begin{DoxyParamCaption}\item[{std\+::map$<$ std\+::vector$<$ int $>$, int $>$ \&}]{tabu\+\_\+list }\end{DoxyParamCaption})}



Updates the tabu list by decreasing the tenure of each path and removing those with expired tenure. 


\begin{DoxyParams}{Parameters}
{\em tabu\+\_\+list} & The tabu list mapping paths to their remaining tenure.\\
\hline
\end{DoxyParams}
@timecomplexity O(k) where k is the number of paths in the tabu list. \Hypertarget{algorithms_8cpp_a8b46ff3a5dc6c342348e977165ca3dbc}\label{algorithms_8cpp_a8b46ff3a5dc6c342348e977165ca3dbc} 
\index{algorithms.cpp@{algorithms.cpp}!vectorContainsVal@{vectorContainsVal}}
\index{vectorContainsVal@{vectorContainsVal}!algorithms.cpp@{algorithms.cpp}}
\doxysubsubsection{\texorpdfstring{vectorContainsVal()}{vectorContainsVal()}}
{\footnotesize\ttfamily bool vector\+Contains\+Val (\begin{DoxyParamCaption}\item[{std\+::vector$<$ int $>$}]{vec,  }\item[{int}]{val }\end{DoxyParamCaption})}



Auxiliary function that checks if a vector contains a given value. 


\begin{DoxyParams}{Parameters}
{\em vec} & Vector to be checked. \\
\hline
{\em val} & Value to be checked for. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool True if the vector contains the value, false otherwise.
\end{DoxyReturn}
@timecomplexity The time complexity is O(n), where n is the size of the vector. 