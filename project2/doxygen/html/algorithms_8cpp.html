<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Routing Algorithm for Ocean Shipping and Urban Deliveries: code/algorithms.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Routing Algorithm for Ocean Shipping and Urban Deliveries
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">algorithms.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file contains implementations of TSP algorithms using different techniques/approaches, as well as the utility functions used in them.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;unordered_set&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
</div>
<p><a href="algorithms_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6f8c3fb1951a1f05e6b2c8b37cda0a76" id="r_a6f8c3fb1951a1f05e6b2c8b37cda0a76"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f8c3fb1951a1f05e6b2c8b37cda0a76">tsp_backtracking_iteration</a> (Graph&lt; int &gt; g, Vertex&lt; int &gt; *curr, std::vector&lt; int &gt; &amp;path, double cost, double &amp;min_cost, std::vector&lt; int &gt; &amp;best_path)</td></tr>
<tr class="memdesc:a6f8c3fb1951a1f05e6b2c8b37cda0a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to perform backtracking for TSP.  <br /></td></tr>
<tr class="separator:a6f8c3fb1951a1f05e6b2c8b37cda0a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4e302060adb98b28f67602780f019f" id="r_a1f4e302060adb98b28f67602780f019f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f4e302060adb98b28f67602780f019f">tsp_backtracking</a> (Graph&lt; int &gt; g, const int start, std::vector&lt; int &gt; &amp;best_path)</td></tr>
<tr class="memdesc:a1f4e302060adb98b28f67602780f019f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to start the TSP backtracking.  <br /></td></tr>
<tr class="separator:a1f4e302060adb98b28f67602780f019f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b46ff3a5dc6c342348e977165ca3dbc" id="r_a8b46ff3a5dc6c342348e977165ca3dbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b46ff3a5dc6c342348e977165ca3dbc">vectorContainsVal</a> (std::vector&lt; int &gt; vec, int val)</td></tr>
<tr class="memdesc:a8b46ff3a5dc6c342348e977165ca3dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function that checks if a vector contains a given value.  <br /></td></tr>
<tr class="separator:a8b46ff3a5dc6c342348e977165ca3dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb8f9da22252c42a0c4809b9f9def07" id="r_a0fb8f9da22252c42a0c4809b9f9def07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fb8f9da22252c42a0c4809b9f9def07">swap_values</a> (std::vector&lt; int &gt; original, int pos1, int pos2, std::vector&lt; int &gt; &amp;modified)</td></tr>
<tr class="memdesc:a0fb8f9da22252c42a0c4809b9f9def07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the two values in the vector to generate a new neighbor.  <br /></td></tr>
<tr class="separator:a0fb8f9da22252c42a0c4809b9f9def07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b45649b16cd8fb687985b5be820b74a" id="r_a0b45649b16cd8fb687985b5be820b74a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b45649b16cd8fb687985b5be820b74a">is_val_in_vector</a> (std::vector&lt; int &gt; vec, int val)</td></tr>
<tr class="memdesc:a0b45649b16cd8fb687985b5be820b74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies if a given value exists in the given vector.  <br /></td></tr>
<tr class="separator:a0b45649b16cd8fb687985b5be820b74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98321d397e3cd44eb7008becad3b589" id="r_ad98321d397e3cd44eb7008becad3b589"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad98321d397e3cd44eb7008becad3b589">generates_random_vertex</a> (std::vector&lt; int &gt; swappedVertexes, int pathSize, bool isStartVertex)</td></tr>
<tr class="memdesc:ad98321d397e3cd44eb7008becad3b589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random unswapped vertex so that it can be swapped using our neighboring function.  <br /></td></tr>
<tr class="separator:ad98321d397e3cd44eb7008becad3b589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad636dec4a7274e831cde1dc219b98158" id="r_ad636dec4a7274e831cde1dc219b98158"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad636dec4a7274e831cde1dc219b98158">generate_neighbors</a> (std::vector&lt; int &gt; path, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;neighbors, bool tweakable_param)</td></tr>
<tr class="memdesc:ad636dec4a7274e831cde1dc219b98158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the neighbors of a given path.  <br /></td></tr>
<tr class="separator:ad636dec4a7274e831cde1dc219b98158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c75d0e1c4e432164afede952e34ceff" id="r_a0c75d0e1c4e432164afede952e34ceff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c75d0e1c4e432164afede952e34ceff">get_path_cost_feasibility</a> (std::vector&lt; int &gt; path, Graph&lt; int &gt; &amp;g, bool &amp;isPathFeasible, double &amp;pathCost)</td></tr>
<tr class="memdesc:a0c75d0e1c4e432164afede952e34ceff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cost of a given path, as well as its feasibility.  <br /></td></tr>
<tr class="separator:a0c75d0e1c4e432164afede952e34ceff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914120bda1db570cdd5f676d3ce5e90d" id="r_a914120bda1db570cdd5f676d3ce5e90d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a914120bda1db570cdd5f676d3ce5e90d">find_start_path</a> (Graph&lt; int &gt; &amp;g, int start_node, vector&lt; int &gt; &amp;starting_path)</td></tr>
<tr class="memdesc:a914120bda1db570cdd5f676d3ce5e90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random path from the graph. Not known to be feasible, Since we load in the whole graph all the nodes are added to it. But only some edges are loaded based on the dataset. There are some cases, ie. extra fully connected graphs dataset were we only need a small percentege of them. So, in order to avoid generating a path with nodes that are not loaded in, we only load the nodes which have edges assigned. Therefore avoiding the generation of paths with no edges assigned which would break our algorithm since we would no longer have a fully connected graph.  <br /></td></tr>
<tr class="separator:a914120bda1db570cdd5f676d3ce5e90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d53a990c8cec6885ae0d34e48db29cd" id="r_a6d53a990c8cec6885ae0d34e48db29cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d53a990c8cec6885ae0d34e48db29cd">update_tabu_list</a> (std::map&lt; std::vector&lt; int &gt;, int &gt; &amp;tabu_list)</td></tr>
<tr class="memdesc:a6d53a990c8cec6885ae0d34e48db29cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the tabu list by decreasing the tenure of each path and removing those with expired tenure.  <br /></td></tr>
<tr class="separator:a6d53a990c8cec6885ae0d34e48db29cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f9ffdbf0cc13e83342a82e1918539b" id="r_a74f9ffdbf0cc13e83342a82e1918539b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74f9ffdbf0cc13e83342a82e1918539b">meets_aspiration_criteria</a> (std::vector&lt; int &gt; path, std::map&lt; std::vector&lt; int &gt;, int &gt; tabu_list, int tabu_tenure, double best_cost)</td></tr>
<tr class="memdesc:a74f9ffdbf0cc13e83342a82e1918539b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given path meets the aspiration criteria in Tabu Search.  <br /></td></tr>
<tr class="separator:a74f9ffdbf0cc13e83342a82e1918539b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd8c7a0a578c04a5751a972ecaca17a" id="r_aebd8c7a0a578c04a5751a972ecaca17a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebd8c7a0a578c04a5751a972ecaca17a">tabu_search</a> (Graph&lt; int &gt; &amp;g, std::vector&lt; int &gt; starting_path, double starting_cost, std::vector&lt; int &gt; &amp;best_path, double &amp;best_cost)</td></tr>
<tr class="memdesc:aebd8c7a0a578c04a5751a972ecaca17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Tabu Search algorithm to find the optimal path in a graph.  <br /></td></tr>
<tr class="separator:aebd8c7a0a578c04a5751a972ecaca17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e872e775c5f2167f9ce3f9649f52845" id="r_a0e872e775c5f2167f9ce3f9649f52845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e872e775c5f2167f9ce3f9649f52845">T2_3</a> (Graph&lt; int &gt; &amp;g)</td></tr>
<tr class="memdesc:a0e872e775c5f2167f9ce3f9649f52845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to demonstrate the tabu search algorithm on a graph.  <br /></td></tr>
<tr class="separator:a0e872e775c5f2167f9ce3f9649f52845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13935b1770316633a1629fd39a5ff1a" id="r_af13935b1770316633a1629fd39a5ff1a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af13935b1770316633a1629fd39a5ff1a">primUsingEdges</a> (Graph&lt; int &gt; g, int start, vector&lt; Edge&lt; int &gt; * &gt; &amp;mstEdges)</td></tr>
<tr class="memdesc:af13935b1770316633a1629fd39a5ff1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is the prim algorithm for distance datasets (as opposed to coordinate datasets)  <br /></td></tr>
<tr class="separator:af13935b1770316633a1629fd39a5ff1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4e7a479e4a8cba5dbb9162cec10d74" id="r_afe4e7a479e4a8cba5dbb9162cec10d74"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe4e7a479e4a8cba5dbb9162cec10d74">calculateDistance</a> (Vertex&lt; int &gt; *v, Vertex&lt; int &gt; *w)</td></tr>
<tr class="memdesc:afe4e7a479e4a8cba5dbb9162cec10d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the distance between two vertices using their geographical coordinates.  <br /></td></tr>
<tr class="separator:afe4e7a479e4a8cba5dbb9162cec10d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab8f7f2df9abd7ae4fdf38d1f3ea450" id="r_a7ab8f7f2df9abd7ae4fdf38d1f3ea450"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ab8f7f2df9abd7ae4fdf38d1f3ea450">primUsingCoords</a> (Graph&lt; int &gt; g, int start, vector&lt; Edge&lt; int &gt; * &gt; &amp;mstEdges)</td></tr>
<tr class="memdesc:a7ab8f7f2df9abd7ae4fdf38d1f3ea450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prim's algorithm for coordinates datasets.  <br /></td></tr>
<tr class="separator:a7ab8f7f2df9abd7ae4fdf38d1f3ea450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e587049579507b6e91f11255a8d107c" id="r_a0e587049579507b6e91f11255a8d107c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e587049579507b6e91f11255a8d107c">T2_2</a> (Graph&lt; int &gt; g)</td></tr>
<tr class="memdesc:a0e587049579507b6e91f11255a8d107c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to demonstrate Prim's algorithm using both edge weights and vertex coordinates.  <br /></td></tr>
<tr class="separator:a0e587049579507b6e91f11255a8d107c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a952eac791b596a61bba0a133a3bb439f" id="r_a952eac791b596a61bba0a133a3bb439f"><td class="memItemLeft" align="right" valign="top"><a id="a952eac791b596a61bba0a133a3bb439f" name="a952eac791b596a61bba0a133a3bb439f"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>PI</b> = 3.14159265358979323846</td></tr>
<tr class="separator:a952eac791b596a61bba0a133a3bb439f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains implementations of TSP algorithms using different techniques/approaches, as well as the utility functions used in them. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="afe4e7a479e4a8cba5dbb9162cec10d74" name="afe4e7a479e4a8cba5dbb9162cec10d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4e7a479e4a8cba5dbb9162cec10d74">&#9670;&#160;</a></span>calculateDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double calculateDistance </td>
          <td>(</td>
          <td class="paramtype">Vertex&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>v</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the distance between two vertices using their geographical coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The first vertex. </td></tr>
    <tr><td class="paramname">w</td><td>The second vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The calculated distance between the two vertices.</dd></dl>
<p>@timecomplexity O(1) </p>

</div>
</div>
<a id="a914120bda1db570cdd5f676d3ce5e90d" name="a914120bda1db570cdd5f676d3ce5e90d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914120bda1db570cdd5f676d3ce5e90d">&#9670;&#160;</a></span>find_start_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void find_start_path </td>
          <td>(</td>
          <td class="paramtype">Graph&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_node</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>starting_path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random path from the graph. Not known to be feasible, Since we load in the whole graph all the nodes are added to it. But only some edges are loaded based on the dataset. There are some cases, ie. extra fully connected graphs dataset were we only need a small percentege of them. So, in order to avoid generating a path with nodes that are not loaded in, we only load the nodes which have edges assigned. Therefore avoiding the generation of paths with no edges assigned which would break our algorithm since we would no longer have a fully connected graph. </p>
<p>This function ensures that only nodes with edges assigned are included in the generated path, avoiding paths that break the algorithm due to disconnected nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Graph containing the vertices and edges. </td></tr>
    <tr><td class="paramname">start_node</td><td>The starting node for the path. </td></tr>
    <tr><td class="paramname">starting_path</td><td>Vector to store the generated starting path.</td></tr>
  </table>
  </dd>
</dl>
<p>@timecomplexity O(n) where n is the number of vertices in the graph. </p>

</div>
</div>
<a id="ad636dec4a7274e831cde1dc219b98158" name="ad636dec4a7274e831cde1dc219b98158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad636dec4a7274e831cde1dc219b98158">&#9670;&#160;</a></span>generate_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generate_neighbors </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>neighbors</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>tweakable_param</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the neighbors of a given path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Original path. </td></tr>
    <tr><td class="paramname">neighbors</td><td>Vector to store the generated neighbors. </td></tr>
    <tr><td class="paramname">tweakable_param</td><td>Boolean to tweak the number of neighbors generated.</td></tr>
  </table>
  </dd>
</dl>
<p>@timecomplexity The time complexity is O(n^2), where n is the size of the path. </p>

</div>
</div>
<a id="ad98321d397e3cd44eb7008becad3b589" name="ad98321d397e3cd44eb7008becad3b589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98321d397e3cd44eb7008becad3b589">&#9670;&#160;</a></span>generates_random_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int generates_random_vertex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>swappedVertexes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pathSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>isStartVertex</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random unswapped vertex so that it can be swapped using our neighboring function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swappedVertexes</td><td>Vector of already swapped vertexes. </td></tr>
    <tr><td class="paramname">pathSize</td><td>Size of the path. </td></tr>
    <tr><td class="paramname">isStartVertex</td><td>Boolean indicating if it is the start vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Random vertex generated.</dd></dl>
<p>@timecomplexity The time complexity is O(1). </p>

</div>
</div>
<a id="a0c75d0e1c4e432164afede952e34ceff" name="a0c75d0e1c4e432164afede952e34ceff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c75d0e1c4e432164afede952e34ceff">&#9670;&#160;</a></span>get_path_cost_feasibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_path_cost_feasibility </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Graph&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>isPathFeasible</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>pathCost</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the cost of a given path, as well as its feasibility. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to be evaluated. </td></tr>
    <tr><td class="paramname">g</td><td>Graph containing the vertices and edges. </td></tr>
    <tr><td class="paramname">isPathFeasible</td><td>Boolean indicating if the path is feasible. </td></tr>
    <tr><td class="paramname">pathCost</td><td>Cost of the path.</td></tr>
  </table>
  </dd>
</dl>
<p>@timecomplexity The time complexity is O(n*m), where n is the number of vertices and m is the number of edges. </p>

</div>
</div>
<a id="a0b45649b16cd8fb687985b5be820b74a" name="a0b45649b16cd8fb687985b5be820b74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b45649b16cd8fb687985b5be820b74a">&#9670;&#160;</a></span>is_val_in_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_val_in_vector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>vec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies if a given value exists in the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>Vector to be checked. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be checked for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the vector contains the value, false otherwise.</dd></dl>
<p>@timecomplexity The time complexity is O(n), where n is the size of the vector. </p>

</div>
</div>
<a id="a74f9ffdbf0cc13e83342a82e1918539b" name="a74f9ffdbf0cc13e83342a82e1918539b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f9ffdbf0cc13e83342a82e1918539b">&#9670;&#160;</a></span>meets_aspiration_criteria()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool meets_aspiration_criteria </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::vector&lt; int &gt;, int &gt;</td>          <td class="paramname"><span class="paramname"><em>tabu_list</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tabu_tenure</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>best_cost</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a given path meets the aspiration criteria in Tabu Search. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The current path. </td></tr>
    <tr><td class="paramname">tabu_list</td><td>The list of tabu paths with their tenures. </td></tr>
    <tr><td class="paramname">tabu_tenure</td><td>The tenure of the tabu list. </td></tr>
    <tr><td class="paramname">best_cost</td><td>The best cost found so far. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the path meets the aspiration criteria, false otherwise.</dd></dl>
<p>@timecomplexity O(1) </p>

</div>
</div>
<a id="a7ab8f7f2df9abd7ae4fdf38d1f3ea450" name="a7ab8f7f2df9abd7ae4fdf38d1f3ea450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab8f7f2df9abd7ae4fdf38d1f3ea450">&#9670;&#160;</a></span>primUsingCoords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double primUsingCoords </td>
          <td>(</td>
          <td class="paramtype">Graph&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Edge&lt; int &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mstEdges</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prim's algorithm for coordinates datasets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph containing the vertices. </td></tr>
    <tr><td class="paramname">start</td><td>The starting vertex. </td></tr>
    <tr><td class="paramname">mstEdges</td><td>Output parameter to store the MST edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total weight of the MST.</dd></dl>
<p>@timecomplexity O(n^2 log n) </p>

</div>
</div>
<a id="af13935b1770316633a1629fd39a5ff1a" name="af13935b1770316633a1629fd39a5ff1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13935b1770316633a1629fd39a5ff1a">&#9670;&#160;</a></span>primUsingEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double primUsingEdges </td>
          <td>(</td>
          <td class="paramtype">Graph&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Edge&lt; int &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mstEdges</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this is the prim algorithm for distance datasets (as opposed to coordinate datasets) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph. </td></tr>
    <tr><td class="paramname">start</td><td>The starting vertex. </td></tr>
    <tr><td class="paramname">mstEdges</td><td>Output parameter to store the MST edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total weight of the MST.</dd></dl>
<p>@timecomplexity O((n + m) log n) </p>

</div>
</div>
<a id="a0fb8f9da22252c42a0c4809b9f9def07" name="a0fb8f9da22252c42a0c4809b9f9def07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb8f9da22252c42a0c4809b9f9def07">&#9670;&#160;</a></span>swap_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap_values </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>original</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pos1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pos2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>modified</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the two values in the vector to generate a new neighbor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>Original vector. </td></tr>
    <tr><td class="paramname">pos1</td><td>Position of the first value. </td></tr>
    <tr><td class="paramname">pos2</td><td>Position of the second value. </td></tr>
    <tr><td class="paramname">modified</td><td>Vector to store the modified version.</td></tr>
  </table>
  </dd>
</dl>
<p>@timecomplexity The time complexity is O(n), where n is the size of the vector. </p>

</div>
</div>
<a id="a0e587049579507b6e91f11255a8d107c" name="a0e587049579507b6e91f11255a8d107c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e587049579507b6e91f11255a8d107c">&#9670;&#160;</a></span>T2_2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void T2_2 </td>
          <td>(</td>
          <td class="paramtype">Graph&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to demonstrate Prim's algorithm using both edge weights and vertex coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph to be used for the demonstration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e872e775c5f2167f9ce3f9649f52845" name="a0e872e775c5f2167f9ce3f9649f52845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e872e775c5f2167f9ce3f9649f52845">&#9670;&#160;</a></span>T2_3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void T2_3 </td>
          <td>(</td>
          <td class="paramtype">Graph&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to demonstrate the tabu search algorithm on a graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph to be used for the demonstration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebd8c7a0a578c04a5751a972ecaca17a" name="aebd8c7a0a578c04a5751a972ecaca17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd8c7a0a578c04a5751a972ecaca17a">&#9670;&#160;</a></span>tabu_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tabu_search </td>
          <td>(</td>
          <td class="paramtype">Graph&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>starting_path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>starting_cost</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>best_path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>best_cost</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the Tabu Search algorithm to find the optimal path in a graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph on which the search is performed. </td></tr>
    <tr><td class="paramname">starting_path</td><td>The initial path to start the search. </td></tr>
    <tr><td class="paramname">starting_cost</td><td>The cost of the initial path. </td></tr>
    <tr><td class="paramname">best_path</td><td>Output parameter to store the best path found. </td></tr>
    <tr><td class="paramname">best_cost</td><td>Output parameter to store the cost of the best path found.</td></tr>
  </table>
  </dd>
</dl>
<p>@timecomplexity O(iterations * neighbors * (log neighbors + feasibility check)) </p>

</div>
</div>
<a id="a1f4e302060adb98b28f67602780f019f" name="a1f4e302060adb98b28f67602780f019f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4e302060adb98b28f67602780f019f">&#9670;&#160;</a></span>tsp_backtracking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tsp_backtracking </td>
          <td>(</td>
          <td class="paramtype">Graph&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>best_path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to start the TSP backtracking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Graph containing the vertices and edges. </td></tr>
    <tr><td class="paramname">start</td><td>Starting vertex for TSP. </td></tr>
    <tr><td class="paramname">best_path</td><td>Vector to store the best path found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double Minimum cost found.</dd></dl>
<p>@timecomplexity The time complexity is O(n!), where n is the number of vertices in the graph. </p>

</div>
</div>
<a id="a6f8c3fb1951a1f05e6b2c8b37cda0a76" name="a6f8c3fb1951a1f05e6b2c8b37cda0a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8c3fb1951a1f05e6b2c8b37cda0a76">&#9670;&#160;</a></span>tsp_backtracking_iteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tsp_backtracking_iteration </td>
          <td>(</td>
          <td class="paramtype">Graph&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&lt; int &gt; *</td>          <td class="paramname"><span class="paramname"><em>curr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>cost</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>min_cost</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>best_path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to perform backtracking for TSP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Graph containing the vertices and edges. </td></tr>
    <tr><td class="paramname">curr</td><td>Current vertex in the path. </td></tr>
    <tr><td class="paramname">path</td><td>Vector containing the current path. </td></tr>
    <tr><td class="paramname">cost</td><td>Current cost of the path. </td></tr>
    <tr><td class="paramname">min_cost</td><td>Minimum cost found so far. </td></tr>
    <tr><td class="paramname">best_path</td><td>Vector containing the best path found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double Minimum cost found.</dd></dl>
<p>@timecomplexity The time complexity is O(n!), where n is the number of vertices in the graph. </p>

</div>
</div>
<a id="a6d53a990c8cec6885ae0d34e48db29cd" name="a6d53a990c8cec6885ae0d34e48db29cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d53a990c8cec6885ae0d34e48db29cd">&#9670;&#160;</a></span>update_tabu_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_tabu_list </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::vector&lt; int &gt;, int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tabu_list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the tabu list by decreasing the tenure of each path and removing those with expired tenure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tabu_list</td><td>The tabu list mapping paths to their remaining tenure.</td></tr>
  </table>
  </dd>
</dl>
<p>@timecomplexity O(k) where k is the number of paths in the tabu list. </p>

</div>
</div>
<a id="a8b46ff3a5dc6c342348e977165ca3dbc" name="a8b46ff3a5dc6c342348e977165ca3dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b46ff3a5dc6c342348e977165ca3dbc">&#9670;&#160;</a></span>vectorContainsVal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vectorContainsVal </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>vec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary function that checks if a vector contains a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>Vector to be checked. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be checked for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the vector contains the value, false otherwise.</dd></dl>
<p>@timecomplexity The time complexity is O(n), where n is the size of the vector. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
